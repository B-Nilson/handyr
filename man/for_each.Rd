% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/for_each.R
\name{for_each}
\alias{for_each}
\title{Loop over a vector-like object and apply a function}
\usage{
for_each(
  x,
  FUN,
  ...,
  .enumerate = FALSE,
  .bind = FALSE,
  .bind_id = NULL,
  .join = FALSE,
  .join_by = NULL,
  .join_mode = "full",
  .name = FALSE,
  .as_list = NULL,
  .parallel = FALSE,
  .workers = NULL,
  .plan = "multisession",
  .parallel_cleanup = TRUE,
  .show_progress = !.quiet,
  .quiet = FALSE
)
}
\arguments{
\item{x}{Something iterable (a vector, list, etc).}

\item{FUN}{A function to be applied to each entry in \code{x}.}

\item{...}{Additional arguments to be passed to \code{FUN} or to \code{\link[future.apply:future_lapply]{future.apply::future_lapply()}} if \code{.parallel = TRUE}.}

\item{.enumerate}{A logical value indicating if \code{i} should be passed to \code{FUN} alongside \code{x}.
Default is \code{FALSE}.
If \code{TRUE}, \code{FUN} is run as \code{FUN(x[[i]], i, ...)}, where \code{i} is the index of values in \code{x}.}

\item{.bind}{A logical value indicating whether to apply \code{\link[dplyr:bind_rows]{dplyr::bind_rows()}}.
Default is \code{FALSE}}

\item{.bind_id}{A single character string indicating the column name to use for the row index if \code{.bind = TRUE}.
Default is \code{NULL} (don't add a row index column).}

\item{.join}{A logical value indicating if the output should be joined using \code{\link[=join_list]{join_list()}}.
Default is \code{FALSE}.}

\item{.join_by}{One or more character values indicating the column name(s) to join by if \code{.join = TRUE}.
Default is \code{NULL}, which joins on all matching columns.}

\item{.join_mode}{A character string specifying the type of join to perform if \code{.join = TRUE}. Must be one of "full", "inner", "left", "right", ... (see \code{\link[=join_list]{join_list()}} for all options).
Default is "full", which uses \code{\link[dplyr:mutate-joins]{dplyr::full_join()}}.}

\item{.name}{A logical value indicating if the output should be named after \code{x}. (i.e \code{names(out) <- x})
Default is \code{FALSE}.}

\item{.as_list}{A logical value indicating if the output should be a list (see \code{\link[=lapply]{lapply()}} / \code{\link[future.apply:future_lapply]{future.apply::future_lapply()}}) or a vector (see\code{\link[=sapply]{sapply()}} / \code{\link[future.apply:future_lapply]{future.apply::future_sapply()}}).
Default is \code{NULL}, which is \code{FALSE} if \code{x} is a vector, \code{TRUE} otherwise.}

\item{.parallel}{A logical value indicating if the function should be run in parallel (see \code{\link[future:multisession]{future::multisession()}}).
Default is \code{FALSE}.}

\item{.workers}{A single numeric value indicating the number of workers to run in parallel if \code{.parallel = TRUE}.
Default is \code{NULL} which uses all available cores (see \code{\link[parallel:detectCores]{parallel::detectCores()}}).}

\item{.plan}{A string indicating the strategy to use if \code{.parallel = TRUE}.
Default is \code{"multisession"} (see \code{\link[future:plan]{future::plan()}}).}

\item{.parallel_cleanup}{A logical value indicating if the parallel plan should be reset to sequential using \code{future::plan("sequential")} if \code{.parallel = TRUE}.
Default is \code{TRUE}.}

\item{.show_progress}{A logical value indicating if the progress bar (see \code{\link[pbapply:pbapply]{pbapply::pbsapply()}}) should be shown if \code{.parallel = TRUE}.
Default is \code{!.quiet}.}

\item{.quiet}{A logical value indicating if the output should be invisible (no messages/warnings).
Default is \code{FALSE}.}
}
\value{
a list of the output of \code{FUN} iterated over \code{x} which:
if \code{.bind = TRUE}: is bound rowwise into a data frame using \code{\link[dplyr:bind_rows]{dplyr::bind_rows()}}
if \code{.name = TRUE}: has names set to \code{x} using \code{names(out) <- x}
if \code{.quiet = TRUE}: is invisible
}
\description{
\code{for_each} provides a simple way to loop over a vector and apply a function with useful postprocessing.
}
\examples{
1:3 |> for_each(\(value) value + 1)
c(7, 7, 7) |> for_each(\(value, i) value + i, .enumerate = TRUE)

list(
  data.frame(x = 1:3),
  data.frame(x = 4:6)
) |>
  for_each(
    \(dat) dat |> dplyr::mutate(y = x + 1),
    .bind = TRUE
  )

c("bread", "jam") |>
  for_each(
    \(value) paste("eat", value),
    .name = TRUE
  )

values <- 1:3 |>
  for_each(\(value) value + 1, .parallel = TRUE, .workers = 2, .as_list = TRUE)

values <- 1:3 |>
  for_each(\(value) message(value + 1), .quiet = TRUE)
}
